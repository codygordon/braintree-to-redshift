const moment = require('moment');

// takes an object like { prefix: {value: true} } and returns { prefix_value: true }
const prefixKeys = obj => {
  const result = {};
  Object.keys(obj).forEach(prefix => {
    const values = obj[prefix];

    Object.keys(values).forEach(key => {
      // ignore the getGateway function on each of these...
      if (key === 'getGateway') { return }
      result[`${prefix}_${key}`] = values[key];
    });
  });

  return result;
}

exports.transactions = ({
  customer,
  billing,
  shipping,
  creditCard,
  subscription,
  disbursementDetails,
  statusHistory,
  createdAt,
  updatedAt,
  refundIds,
  partialSettlementTransactionIds,
  addOns,
  discounts,
  descriptor,
  disputes,
  authorizationAdjustments,
  paypalAccount,
  coinbaseAccount,
  applePayCard,
  androidPayCard,
  visaCheckoutCard,
  masterpassCard,
  riskData,
  getGateway,
  ...fields
}) => ({
  ...fields,
  ...prefixKeys({ customer, billing, shipping, creditCard, subscription, disbursementDetails, descriptor }),
  // refundIds: refundIds.join(', '),
  // partialSettlementTransactionIds: partialSettlementTransactionIds.join(', '),
  // addOns: JSON.stringify(addOns),
  // discounts: JSON.stringify(discounts),
  // disputes: JSON.stringify(disputes),
  // authorizationAdjustments: JSON.stringify(authorizationAdjustments),
  // paypalAccount: JSON.stringify(paypalAccount),
  // coinbaseAccount: JSON.stringify(coinbaseAccount),
  // applePayCard: JSON.stringify(applePayCard),
  // androidPayCard: JSON.stringify(androidPayCard),
  // visaCheckoutCard: JSON.stringify(visaCheckoutCard),
  // masterpassCard: JSON.stringify(masterpassCard),
  // statusHistory: JSON.stringify(statusHistory),
  createdAt: moment(createdAt).format('YYYY-MM-DD HH:mm:ss'),
  updatedAt: moment(updatedAt).format('YYYY-MM-DD HH:mm:ss'),
});

exports.subscriptions = ({
  id,
  balance,
  createdAt,
  updatedAt,
  billingPeriodEndDate,
  billingPeriodStartDate,
  billingDayOfMonth,
  currentBillingCycle,
  daysPastDue,
  failureCount,
  description,
  firstBillingDate,
  merchantAccountId,
  neverExpires,
  nextBillAmount,
  nextBillingDate,
  nextBillingPeriodAmount,
  numberOfBillingCycles,
  paidThroughDate,
  paymentMethodToken,
  planId,
  price,
  status,
  trialDuration,
  trialDurationUnit,
  trialPeriod,
}) => ({
  id,
  balance,
  createdAt: moment(createdAt).format('YYYY-MM-DD HH:mm:ss'),
  updatedAt: moment(updatedAt).format('YYYY-MM-DD HH:mm:ss'),
  billingPeriodStartDate: moment(billingPeriodStartDate).format('YYYY-MM-DD HH:mm:ss'),
  billingPeriodEndDate: moment(billingPeriodEndDate).format('YYYY-MM-DD HH:mm:ss'),
  billingDayOfMonth,
  currentBillingCycle,
  daysPastDue,
  failureCount,
  description,
  firstBillingDate: moment(firstBillingDate).format('YYYY-MM-DD HH:mm:ss'),
  merchantAccountId,
  neverExpires,
  nextBillAmount,
  nextBillingDate: moment(nextBillingDate).format('YYYY-MM-DD HH:mm:ss'),
  nextBillingPeriodAmount,
  numberOfBillingCycles,
  paidThroughDate,
  paymentMethodToken,
  planId,
  price,
  status,
  trialDuration,
  trialDurationUnit,
  trialPeriod,
});

exports.disputes = ({
  id,
  amountDisputed,
  amountWon,
  caseNumber,
  createdAt,
  updatedAt,
  currencyIsoCode,
  kind,
  merchantAccountId,
  originalDisputeId,
  processorComments,
  reason,
  reasonCode,
  reasonDescription,
  receivedDate,
  referenceNumber,
  replyByDate,
  status,
  transaction,
}) => ({
  id,
  amountDisputed,
  amountWon,
  caseNumber,
  createdAt: moment(createdAt).format('YYYY-MM-DD HH:mm:ss'),
  updatedAt: moment(updatedAt).format('YYYY-MM-DD HH:mm:ss'),
  currencyIsoCode,
  kind,
  merchantAccountId,
  originalDisputeId,
  processorComments,
  reason,
  reasonCode,
  reasonDescription,
  receivedDate: moment(receivedDate).format('YYYY-MM-DD HH:mm:ss'),
  referenceNumber,
  replyByDate: moment(replyByDate).format('YYYY-MM-DD HH:mm:ss'),
  status,
  transactionId: transaction.id,
});
